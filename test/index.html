<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Interactive Net Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; }
        canvas { display: block; }
        .guide {
            position: absolute; top: 20px; left: 20px; color: white;
            font-family: sans-serif; pointer-events: none;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
        }
    </style>
</head>
<body>

<div class="guide">ğŸ•¸ï¸ ë§ˆìš°ìŠ¤ ì™¼ìª½ ë²„íŠ¼ì„ ëˆ„ë¥´ê³  <b>ê·¸ë¬¼ì„ ì˜ë¼ë³´ì„¸ìš”!</b></div>
<canvas id="c"></canvas>

<script>
// 1. ì„¤ì • (Settings)
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

// ë¬¼ë¦¬ ë³€ìˆ˜
const gravity = 0.5;   // ì¤‘ë ¥
const friction = 1.02; // ë§ˆì°°ë ¥ (ê³µê¸°ì €í•­)
const bounce = 0.9;    // íƒ„ì„±

// ê·¸ë¬¼ ì„¤ì •
const cols = 20;       // ê°€ë¡œ ì  ê°œìˆ˜
const rows = 15;       // ì„¸ë¡œ ì  ê°œìˆ˜
const spacing = 30;    // ì  ì‚¬ì´ ê°„ê²©

let points = [];
let sticks = [];

// 2. í´ë˜ìŠ¤ ì •ì˜ (Class Definitions)

// ì  (Particle)
class Point {
    constructor(x, y, pinned) {
        this.x = x;
        this.y = y;
        this.oldx = x; // ì´ì „ ìœ„ì¹˜ (ì†ë„ ê³„ì‚°ìš©: Verlet Integration)
        this.oldy = y;
        this.pinned = pinned; // ê³ ì • ì—¬ë¶€
    }

    update() {
        if (this.pinned) return;

        // ì†ë„ ê³„ì‚° (í˜„ì¬ ìœ„ì¹˜ - ì´ì „ ìœ„ì¹˜)
        let vx = (this.x - this.oldx) * friction;
        let vy = (this.y - this.oldy) * friction;

        this.oldx = this.x;
        this.oldy = this.y;

        this.x += vx;
        this.y += vy;
        this.y += gravity; // ì¤‘ë ¥ ì ìš©

        // ë°”ë‹¥ ì¶©ëŒ ì²˜ë¦¬
        if (this.y > height) {
            this.y = height;
            this.oldy = this.y + vy * bounce;
        }
    }
}

// ì„  (Stick/Constraint)
class Stick {
    constructor(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
        // ë‘ ì  ì‚¬ì´ì˜ ì´ˆê¸° ê±°ë¦¬ë¥¼ ê¸°ì–µí•¨
        this.length = Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    update() {
        // í˜„ì¬ ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
        const dx = this.p2.x - this.p1.x;
        const dy = this.p2.y - this.p1.y;
        const dist = Math.hypot(dx, dy);
        
        // ê±°ë¦¬ê°€ ë„ˆë¬´ ë©€ê±°ë‚˜ ê°€ê¹Œìš°ë©´ ìˆ˜ì • (Difference)
        const diff = this.length - dist;
        const percent = diff / dist / 2;
        const offsetX = dx * percent;
        const offsetY = dy * percent;

        if (!this.p1.pinned) {
            this.p1.x -= offsetX;
            this.p1.y -= offsetY;
        }
        if (!this.p2.pinned) {
            this.p2.x += offsetX;
            this.p2.y += offsetY;
        }
    }

    draw() {
        ctx.beginPath();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.moveTo(this.p1.x, this.p1.y);
        ctx.lineTo(this.p2.x, this.p2.y);
        ctx.stroke();
    }
}

// 3. ì´ˆê¸°í™” (Init)
function init() {
    points = [];
    sticks = [];
    
    // ì  ìƒì„±
    for(let y = 0; y < rows; y++) {
        for(let x = 0; x < cols; x++) {
            // ì²« ë²ˆì§¸ ì¤„(y==0)ì€ ê³ ì •(pinned: true)
            let p = new Point(x * spacing + width/3, y * spacing + 50, y === 0);
            points.push(p);
        }
    }

    // ì„  ì—°ê²°
    for(let y = 0; y < rows; y++) {
        for(let x = 0; x < cols; x++) {
            let i = y * cols + x;
            if (x < cols - 1) sticks.push(new Stick(points[i], points[i+1])); // ì˜¤ë¥¸ìª½ ì—°ê²°
            if (y < rows - 1) sticks.push(new Stick(points[i], points[i+cols])); // ì•„ë˜ìª½ ì—°ê²°
        }
    }
}

// 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ (Loop)
function animate() {
    ctx.clearRect(0, 0, width, height);

    // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
    points.forEach(p => p.update());
    
    // ì„  ê¸¸ì´ë¥¼ ë§ì¶”ëŠ” ì‘ì—…ì„ ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí• ìˆ˜ë¡ íŒ½íŒ½í•´ì§ (Solver Iteration)
    for(let i=0; i<3; i++) {
        sticks.forEach(s => s.update());
    }

    // ê·¸ë¦¬ê¸°
    sticks.forEach(s => s.draw());
    points.forEach(p => {
        // ì  ê·¸ë¦¬ê¸° (ì„ íƒ ì‚¬í•­)
        // ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
    });

    requestAnimationFrame(animate);
}

// 5. ë§ˆìš°ìŠ¤ ìƒí˜¸ì‘ìš© (ìë¥´ê¸° ê¸°ëŠ¥)
let isMouseDown = false;

window.addEventListener('mousedown', () => isMouseDown = true);
window.addEventListener('mouseup', () => isMouseDown = false);
window.addEventListener('mousemove', (e) => {
    if (!isMouseDown) return;

    // ë§ˆìš°ìŠ¤ ê·¼ì²˜ì˜ ì„ (Stick)ì„ ì°¾ì•„ì„œ ì œê±°
    const cutRadius = 10;
    // filterë¥¼ ì‚¬ìš©í•´ ì˜ë¦¬ì§€ ì•Šì€ ì„ ë§Œ ë‚¨ê¹€
    sticks = sticks.filter(s => {
        // ì ê³¼ ì„  ì‚¬ì´ì˜ ê±°ë¦¬ê°€ ì•„ë‹ˆë¼, ì„ ì˜ ì¤‘ì‹¬ì ê³¼ ë§ˆìš°ìŠ¤ ê±°ë¦¬ë¥¼ ëŒ€ëµ ê³„ì‚°
        const midX = (s.p1.x + s.p2.x) / 2;
        const midY = (s.p1.y + s.p2.y) / 2;
        const dist = Math.hypot(e.clientX - midX, e.clientY - midY);
        return dist > cutRadius; // ê±°ë¦¬ê°€ ë©€ë©´ ë‚¨ê¸°ê³ , ê°€ê¹Œìš°ë©´(false) ì‚­ì œ
    });
});

init();
animate();

</script>
</body>
</html>